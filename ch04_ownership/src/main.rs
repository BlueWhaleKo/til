// Rust에서는 가비지 콜렉터에 의존하지 않고도 메모리 안정성을 보장하려는 Ownership이라는 개념을 갖고 있다.
// Rust에서는 데이터가 어떤 메모리(heap or stack)에 저장되어 있는지에 따라서 언어의 동장이나 의사결정이 크게 달라진다.

// 스택에 저장되어 있는 데이터는 모두 고정된 크기를 가져야한다.
// 띠라서, 컴파일 시점에 크기를 알 수 없는 데이터나 런타임에 동적으로 크기가 변하는 데이터는 힙 메모리에 저장된다.

// 운영체제는 메모리에서 빈 공간을 찾아서 데이터에 메모리를 할당(allocate)하고 포인터(메모리 주소를 가르키는 객체)를 반환한다.
// 반면, Stack 메모리에 올라간 데이터에서는 할당 작업이 필요하지 않다 ==> 더 빠름

// 코드에서 함수를 호출할 때는 매개변수들이 로컬 변수에 할당되어 스택에 저장되고, 함수 호출이 끝나면 스택에서 제거됨

// Rust의 Ownership은 힙에 저장되는 데이터의 중복을 최소하하고 힙 메모리를 최적화하기 위한 개념

// 소유권 규칙
// 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있다.
// 특정 시점에 값의 소유자는 단 하나 뿐이다.
// 소유자가 범위(Scope)를 벗어나면 그 값은 제거된다.

fn main() {
    fn_string();
    fn_move();
}
fn fn_string() {
// 앞서 살펴본 데이터 타입들은 모두 스택에 저장되며 범위를 벗어나면 스택에서 제거됨
    // 반면 이제부터 살펴본 데이터 타입들은 힙에 저장되며 데이터가 제거되는 시점이 다름

    // String Type
    // 다음과 같은 문자열 리터럴의 단점을 개선하기 위한 데이터 타입
    // - immutable
    // - 동적 할당 불가 (컴파일 시점에서 길이를 알 수 없어서, 바이너리 형태로 미리 변환할 수 없음)
    
    let mut s = String::from("Hello"); // heap 메모리 공간 요청
    s.push_str(", String!"); // push_str() 매서드는 String 인스턴스에 문자열 리터럴을 결합한다.

    println!("{}", s);

} // fn_string 함수의 범위를 벗어난 시점에서 s는 더 이상 유효하지 않음 
// 일반적인 프로그래밍 언어에서는 GC가 사용하지 않는 메모리를 추적해 해제한다.
// 러스트는 닫는 중괄호를 만나면 자동으로 drop 함수를 호출해서 자원을 해제함 => RAII

fn fn_move(){
    // 변수와 데이터가 상호작용하는 방식

    // 리터럴 타입은 deep copy
    // 그 외에는 shallow copy (포인터, 길이, 용량만 복사)
    
    let s1 = String::from("Let's Move!");
    let s2 = s1; // Rust는 shallow copy가 발생하면 이전 변수를 무효화 시켜버림 (move) => s1에 접근 불가

    // 따라서, 아래 식은 에러를 발생시킴
    // println!("{}", s1); 
    println!("{}", s2);

}