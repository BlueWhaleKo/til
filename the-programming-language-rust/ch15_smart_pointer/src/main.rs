fn main() {
    println!("Hello, world!");
}

// 15. 스마트한 포인터
// 스마트 포인터는 포인터처럼 동작할 뿐만 아니라 추가적인 메타데이터를 제공한다.
// 스마트 포인터는 원래 C++에서 유래한 것이며, 다른 언어에도 있다.

// 참조와 스마트 포인터의 차이점
// 참조는 데이터를 대여할 수 있지만, 스마트 포인터는 대부분 포인터가 가르키는 데이터를 소유한다.

// 스마트 포인터라고 부르지는 않았지만, String과 Vec<T> 타입이 그 예다.
// 이 두 타입은 모두 메모리를 소유하며 데이터를 갱신할 수 있으므로 스마트 포인터다.
// 또한, 메타데이터(저장 요량 등)와 추가 기능이나 보장(String은 모든 데이터가 항상 유효한 UTF-8 문자임을 보장한다.)

// 스마트 포인터는 주로 구조체를 이용해 구현한다.
// 스마트 포인터는 일반 구조체와 달리 Deref와 Drop 트레이트를 구현한다.
// Deref 트레이트는 스마트 포인터 구조체가 참조처럼 동작해서 참조나 스마트 포인터를 같은 방법으로 다룰 수 있도록 지원한다.
// Drop 트레이트는 스마트 포인터의 인스턴스가 범위를 벗어날 때 임의의 코드를 실행하도록 지원한다.

// 러스트에서 스마트 포인터 패턴은 매우 보편적인 패턴이다.
// 많은 라이브러리가 각자의 스마트 포인터를 지원하며 독자들도 원한다며 얼마든지 작성할 수 있다.

// 힙 메모리에 값을 할당하는 Box<T> 구조체
// 다중 소유권을 지원하고자 참조 카운트를 수행하는 Rc<T> 구조체
// 런타임이 아닌 컴파일 타임에 대여 규칙을 적용하는 타입인 RefCell<T>를 통해 접근하는 Ref<T>와 RefMut<T> 구조체
// + 불변 타입이 내부의 값을 변경하는 API를 노출하는 내부 가변성(interior mutability) 패턴
// + 메모리 누수를 유발하는 순환 참조(reference cycles)를 방지하는 방법
